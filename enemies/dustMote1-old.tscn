[gd_scene load_steps=21 format=3 uid="uid://dhsn84rl46wiu"]

[ext_resource type="PackedScene" uid="uid://b4w5idye15i38" path="res://characters/dieOnZeroHp.tscn" id="2_w4e45"]
[ext_resource type="PackedScene" uid="uid://dt0l2qsjnfbnb" path="res://items/basicLootBag.tscn" id="3_ggkc0"]
[ext_resource type="PackedScene" uid="uid://c1r4djsndgyme" path="res://items/basicArmor1.tscn" id="4_gw6bl"]
[ext_resource type="Material" uid="uid://on8q1sp20o0w" path="res://outlineMaterial.tres" id="5_785rt"]
[ext_resource type="Texture2D" uid="uid://b52jquxvluu7v" path="res://enemies/ash-mote-1.png" id="6_hlf5o"]
[ext_resource type="PackedScene" uid="uid://bc4u5p3urh3h6" path="res://abilities/shots/basicSwipe2.tscn" id="7_5qofr"]
[ext_resource type="Texture2D" uid="uid://c3wtykrn61wf6" path="res://abilities/shots/basicSwipe.png" id="8_35tak"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_lhxg7"]
size = Vector2(8, 8)

[sub_resource type="GDScript" id="GDScript_ukxk7"]
script/source = "extends Node

@export var initial_max_hp = 100.0
@export var initial_hp = 100.0
@export var initial_hp_regen = 1.0 #hp / second

@export var initial_mdef = 1.0 #multiplicative defence, divides damage taken
@export var initial_adef = 0.0 #additive defence, subtracts from damage taken up to 0

@export var always_overheal = false
@export var can_overheal = false

var next_hp_regen_time = 0
var hp_regen_delay = 1000


func _enter_tree():
  var parent = get_parent()
  
  Comp.set_prop(parent, 'hp', initial_hp)
  Comp.set_prop(parent, 'max_hp', initial_max_hp)
  Comp.set_prop(parent, 'hp_regen', initial_hp_regen)
  Comp.set_prop(parent, 'mdef', initial_mdef)
  Comp.set_prop(parent, 'adef', initial_adef)
  
  Comp.set_prop(parent, 'heal_by', Callable(self, 'heal_by'))
  Comp.set_prop(parent, 'overheal_by', Callable(self, 'overheal_by'))
  Comp.set_prop(parent, 'hurt_by', Callable(self, 'hurt_by'))


func hurt_by(dmg: float, _dmger: Object):
  var parent = get_parent()
  var hp = parent.get_meta('hp')
  var mdef = parent.get_meta('mdef')
  var adef = parent.get_meta('adef')
  var new_hp = hp - max(0, dmg * mdef - adef)
  Comp.set_prop(parent, 'hp', new_hp)


func heal_by(change: float):
  var parent = get_parent()
  var hp = parent.get_meta('hp')
  var max_hp = parent.get_meta('max_hp')
  var new_hp = (hp + change) if always_overheal else min(max_hp, hp + change)
  Comp.set_prop(parent, 'hp', new_hp)


func overheal_by(change: float):
  if not can_overheal:
    heal_by(change)
    return
  var parent = get_parent()
  var hp = parent.get_meta('hp')
  var new_hp = hp + change
  Comp.set_prop(parent, 'hp', new_hp)


var active_ui_display_element: Control = null
func make_stat_display_element():
  var template_node = $templateUiStatDisplayElement
  if template_node == null:
    push_error('No template node for healthStats make_ui_display_element')
    return
  
  if active_ui_display_element != null:
    #remove already-present element
    active_ui_display_element.queue_free()
  
  var element = template_node.duplicate(DUPLICATE_GROUPS & DUPLICATE_SCRIPTS & DUPLICATE_SIGNALS)
  element.visible = true
  element.process_mode = Node.PROCESS_MODE_INHERIT
  
  var parent = get_parent()
  
  var hp_label = element.get_node('hpHBox/currentHpValueLabel')
  Comp.call_on_set_prop_and_now(parent, 'hp', func():
    var hp = Comp.get_prop(parent, 'hp')
    hp_label.text = str(hp)
  )
  
  var max_hp_label = element.get_node('hpHBox/maxHpValueLabel')
  Comp.call_on_set_prop_and_now(parent, 'max_hp', func():
    var max_hp = Comp.get_prop(parent, 'max_hp')
    max_hp_label.text = str(max_hp)
    prints(max_hp)
  )
  
  var hp_regen_label = element.get_node('regenHBox/hpRegenLabel')
  Comp.call_on_set_prop_and_now(parent, 'hp_regen', func():
    var hp_regen = Comp.get_prop(parent, 'hp_regen')
    hp_regen_label.text = str(hp_regen)
  )
  
  var adef_label = element.get_node('adefHBox/adefValueLabel')
  Comp.call_on_set_prop_and_now(parent, 'adef', func():
    var adef = Comp.get_prop(parent, 'adef')
    if adef != 0:
      adef_label.text = str(adef)
      element.get_node('adefLabel').visible = true
      element.get_node('adefHBox').visible = true
    else:
      element.get_node('adefLabel').visible = false
      element.get_node('adefHBox').visible = false
  )
  
  var mdef_label = element.get_node('mdefHBox/mdefValueLabel')
  Comp.call_on_set_prop_and_now(parent, 'mdef', func():
    var mdef = Comp.get_prop(parent, 'mdef')
    if mdef != 1.0:
      mdef_label.text = str(mdef)
      element.get_node('mdefLabel').visible = true
      element.get_node('mdefHBox').visible = true
    else:
      element.get_node('mdefLabel').visible = false
      element.get_node('mdefHBox').visible = false
  )
  
  active_ui_display_element = element
  return element


func _process(_delta):
  var current_time = Time.get_ticks_msec()
  if current_time >= next_hp_regen_time:
    next_hp_regen_time = current_time + hp_regen_delay
    var parent = get_parent()
    var hp = Comp.get_prop(parent, 'hp')
    var hp_regen = Comp.get_prop(parent, 'hp_regen')
    var max_hp = Comp.get_prop(parent, 'max_hp')
    if hp >= max_hp:
      return
    Comp.set_prop(parent, 'hp', min(hp + hp_regen, max_hp))







"

[sub_resource type="GDScript" id="GDScript_a6mdq"]
script/source = "extends Node

@export var initial_spd = 10.0

@export var disabled = false

var last_velocity : Vector2


func _enter_tree():
  var parent = get_parent()
  if not ('velocity' in parent):
    push_error('No velocity in parent')
    return
  if not parent.has_method('move_and_slide'):
    push_error('No move_and_slide in parent')
    return
  
  Watch.set_object_meta(parent, 'spd', initial_spd)
  Watch.set_object_meta(parent, 'walk_by', Callable(self, 'walk_by'))


#move in a particular direction, with collisions
func walk_by(vec: Vector2):
  if disabled:
    return

  if (vec.x == 0) and (vec.y == 0):
    return
  
  var parent = get_parent()
  var spd = parent.get_meta('spd')
  parent.velocity += vec * 6.0 * spd
  last_velocity = parent.velocity


func _physics_process(_delta):
  var parent = get_parent()
  if parent.velocity.x == 0 and parent.velocity.y == 0:
    return
  
  parent.move_and_slide()
  parent.velocity = Vector2(0, 0)
"

[sub_resource type="GDScript" id="GDScript_mc3c8"]
script/source = "extends Node

var global_position_parent
    
@export var disabled = false

@export var stay_distance = 50.0


func _enter_tree():
  global_position_parent = self if ('global_position' in self) else null
  if global_position_parent == null:
    global_position_parent = Lib.get_parent_with_property(self, 'global_position')
  if not global_position_parent:
    push_error('No global position parent found')
    queue_free()    
    return


func _process(_delta):
  if disabled:
    return
  
  var parent = get_parent()
  
  #is there a target?
  var target_object = Comp.get_object_meta(parent, 'target_object')
  if (target_object == null) or (not is_instance_valid(target_object)) or (not ('global_position' in target_object)):
    return
  
  var targets_position = target_object.global_position
  var vec_to_target = global_position_parent.global_position - targets_position
  if vec_to_target.length() >= stay_distance:
    var adjusted_target_point = targets_position + vec_to_target.normalized() * stay_distance
    var move_vec = (adjusted_target_point - global_position_parent.global_position).normalized()
    Comp.call_method(parent, 'walk_by', [move_vec])
  



"

[sub_resource type="GDScript" id="GDScript_r3k68"]
script/source = "extends Node

var global_position_parent

@onready var debug_point : Node2D = get_node_or_null(\"debugPoint\")

@export var disabled = false

@export var movement_rate = 20.0

@export var move_to_radius = 20.0
var move_to_point = Vector2(0.0, 0.0)
var next_move_to_time = 0.0
var next_move_point_delay_ms = 1000


func _enter_tree():
  global_position_parent = self if ('global_position' in self) else null
  if global_position_parent == null:
    global_position_parent = Lib.get_parent_with_property(self, 'global_position')
  if not global_position_parent:
    push_error('No global position parent found')
    queue_free()    
    return
 

func _process(delta):
  if disabled:
    return
  
  var parent = get_parent()
  
  #find a new point to move to if close or old point is old
  var current_time = Time.get_ticks_msec()
  var move_to_vec = move_to_point - global_position_parent.global_position
  if (current_time > next_move_to_time) or (move_to_vec.length() < 1.0):
    move_to_point = global_position_parent.global_position + Lib.cs_vec(randf_range(0.0, 2*PI)) * move_to_radius
    next_move_to_time = current_time + next_move_point_delay_ms
    move_to_vec = move_to_point - global_position_parent.global_position
  
  #move toward that point
  Comp.call_method(parent, 'walk_by', [move_to_vec.normalized() * movement_rate * delta])
  
  if debug_point:
    debug_point.global_position = move_to_point

"

[sub_resource type="GDScript" id="GDScript_lg7e8"]
script/source = "extends Area2D

@export var hates_everyone = false

#does character love or hate obj?
func is_hostile_faction_array(my_faction_array, obj_faction_array):
  for my_faction in my_faction_array:
    #if any of parent my factions are in obj's faction_array then they're best buds
    var my_faction_in_object = (obj_faction_array.find(my_faction) != -1)
    if my_faction_in_object:
      return false #loves
  return true #hates


#is body an enemy? then target. Return true if targeted something
func test_and_switch_target_to_body(body):
  var parent = get_parent()
    
  #does body have a faction?
  if not body.has_meta('faction_array'):
    if hates_everyone and body.is_in_group('character'):
      Watch.set_object_meta(parent, 'target_object', body)
      return true
    else:
      return false
  var body_faction_array = body.get_meta('faction_array')
  
  #do I have a faction?
  var my_faction_array = Comp.get_object_meta(parent, 'faction_array')
  if my_faction_array == null:
    return false
  
  #compare faction arrays
  var obj_is_enemy = is_hostile_faction_array(my_faction_array, body_faction_array)
  if obj_is_enemy:
    Watch.set_object_meta(parent, 'target_object', body)
    return true
  
  #no action taken
  return false
  

#target characters and factioned objects that enter
func _on_targetNearestNonfaction_body_entered(body):
  var parent = get_parent()
  #dont do anything if already have target
  var target_object = Comp.get_object_meta(parent, 'target_object')
  if target_object != null:
    return
  
  #set new target if body is hostile faction
  test_and_switch_target_to_body(body)


#untarget active target if its far away, and then get a new target if there are any
func _on_targetNearestNonfaction_body_exited(body):
  var parent = get_parent()
  #dont untarget current target if it didnt just leave
  var target_object = Comp.get_object_meta(parent, 'target_object')
  if body != target_object:
    return
  
  #get a new target, if there is one still in this area
#  Watch.set_object_meta(parent, 'target_object', null)
  parent.set_meta('target_object', null)
  for overlapping_body in get_overlapping_bodies():
    var has_new_target = test_and_switch_target_to_body(overlapping_body)
    if has_new_target:
      return










"

[sub_resource type="RectangleShape2D" id="RectangleShape2D_fsmxm"]
size = Vector2(100, 100)

[sub_resource type="GDScript" id="GDScript_p77ub"]
script/source = "extends Node

@onready var debug_point = $DebugPoint

var mirrored_target_object


func _enter_tree():
  var parent = get_parent()
  Watch.call_on_set_meta(parent, 'target_object', func():
    mirrored_target_object =  parent.get_meta('target_object')
  )


func _process(_delta):
  if (mirrored_target_object != null) and ('global_position' in mirrored_target_object):
    var target_point = mirrored_target_object.global_position
    Watch.set_object_meta(get_parent(), 'target_point', target_point)
    if debug_point != null:
      debug_point.global_position = target_point

"

[sub_resource type="GDScript" id="GDScript_gsacq"]
script/source = "extends Node

@export var disabled = false

@export var msecs_between_attacks = 200
var next_attack_time = 0


func find_main_attack_ability_and_attack():
  var parent = get_parent()
  var main_attack_node_list = Lib.get_children_in_group(parent, 'main_attack')
  for attack_node in main_attack_node_list:
    if attack_node.has_method('attack'):
      attack_node.attack(parent)
    elif Comp.run_method(parent, 'attack', [parent]):
      return


func _process(_delta):
  if disabled:
    return
  
  var current_time = Time.get_ticks_msec()
  if next_attack_time > current_time:
    return
  
  #shoot if character has target
  var parent = get_parent()
  var target_object = Comp.get_object_meta(parent, 'target_object')
  if (target_object == null) or (not is_instance_valid(target_object)):
    return
  
  next_attack_time = current_time + msecs_between_attacks
  find_main_attack_ability_and_attack()
  
"

[sub_resource type="GDScript" id="GDScript_67g1a"]
script/source = "extends Node2D

var composite

var damage_popup_resource : PackedScene = preload(\"res://damagePopup.tscn\")

var prev_hp = 0

func _enter_tree():
  var parent = get_parent()
  Comp.call_on_set_prop(parent, 'hp', func():
    var hp = Comp.get_prop(parent, 'hp')
    var change = hp - prev_hp
    if change == 0:
      return
    var damage_popup = damage_popup_resource.instantiate()
    damage_popup.set_damage(change)
    call_deferred('add_child', damage_popup)
    prev_hp = hp
  )


func _ready():
  prev_hp = Comp.get_prop(get_parent(), 'hp')
"

[sub_resource type="GDScript" id="GDScript_m1ony"]
script/source = "extends Node

@export var bag_scene: PackedScene

@export var guaranteed_loot_scenes: Array
@export var random_loot_scenes: Array
@export var random_drop_count = 0

func _enter_tree():
  var parent = get_parent()
  var game_world = Lib.get_parent_in_group(self, 'game_world')
  var global_position_parent = Lib.get_parent_with_property(self, 'global_position')
  Watch.call_on_notify(parent, 'die', func():
    var bag_instance = bag_scene.instantiate()
    game_world.add_child(bag_instance)
    bag_instance.global_position = global_position_parent.global_position
    
    #add guaranteed drops
    for loot_scene_obj in guaranteed_loot_scenes:
      if not loot_scene_obj.has_method('instantiate'):
        continue
      var loot_instance = loot_scene_obj.instantiate()
      bag_instance.add_child(loot_instance)
    
    #add random drops
    for i in range(0, random_drop_count):
      var random_loot_scene_obj = random_loot_scenes.pick_random()
      if not random_loot_scene_obj.has_method('instantiate'):
        continue
      var loot_instance = random_loot_scene_obj.instantiate()
      bag_instance.add_child(loot_instance)
  )










"

[sub_resource type="GDScript" id="GDScript_u32rb"]
script/source = "extends Node

func _enter_tree():
  var parent = get_parent()
  Watch.call_on_notify(parent, 'die', func():
    parent.queue_free()
  )
"

[sub_resource type="GDScript" id="GDScript_48n0u"]
script/source = "extends Node

@export var cast_speed = 5.0
@export var damage_mod = 1.0

@export var max_attack_rate = 20
@onready var attack_delay = int(float(10000) / float(max_attack_rate))
var next_attack_time = 0

@export var shot_resource: PackedScene

func _exit_tree():
  self.remove_from_group('main_attack')


#shoot new shot toward target point / target object with shoot delay
func attack(user_object: Object) -> void:
  var current_time = Time.get_ticks_msec()
  if shot_resource and (next_attack_time < current_time):
    next_attack_time = current_time + attack_delay
    var shot = shot_resource.instantiate()
    
    #set shot origin
    var origin_position = Comp.get_object_meta(user_object, 'shot_origin', null)
    if origin_position == null:
      origin_position = user_object.get_prop('shot_origin') if user_object.has_method('get_prop') else null
    if origin_position == null:
      origin_position = user_object.global_position if ('global_position' in user_object) else null
    if origin_position == null:
      origin_position = Lib.get_parent_with_property(self, 'global_position').global_position
    shot.global_position = origin_position
    
    get_viewport().add_child(shot)
    
    #set shot parent object (the shot's creator)
    Watch.set_object_meta(shot, 'source_object', user_object)
    
    var dmg = shot.get_meta('dmg', 1.0)
    Watch.set_object_meta(shot, 'dmg', dmg * damage_mod)
    
    #try shooting toward target if it exists
    var target_point = Comp.get_object_meta(user_object, 'target_point', null)
    if origin_position == null:
      origin_position = Comp.get_object_meta(user_object, 'target_point') 
    if target_point == null:
      var target_object = Comp.get_object_meta(user_object, 'target_object')
      if target_object != null:
        target_point = target_object.global_position
    
    if target_point != null:
      if Comp.run_method(shot, 'cast_toward', [target_point, cast_speed]):
        return
      elif Comp.run_method(shot, 'shoot_in_dir', [(target_point - origin_position).normalized(), cast_speed]):
        return
      var shot_velocity = shot.get('velocity')
      if (shot_velocity != null) and ('velocity' in shot):
        shot.velocity = (target_point - origin_position).normalized() * cast_speed
        return
      else:
        push_error('Shot has no way of being projected toward target point')
        return
      
    #else, try shooting in a direction
    var shoot_dir = Comp.get_object_meta(user_object, 'shoot_dir')
    if shoot_dir != null:
      shoot_dir = shoot_dir.normalized()
      if Comp.run_method(shot, 'shoot_in_dir', [shoot_dir.normalized(), cast_speed]):
        return
      var shot_velocity = Comp.get_prop(shot, 'shot_velocity')
      if (shot_velocity != null) and ('velocity' in shot):
        shot.velocity = [shoot_dir.normalized() * cast_speed]
        return
      else:
        push_error('Shot has no way of being projected in shoot direction')
        return


func toggle_equipped(_user_object: Object) -> void:
  var group_status = is_in_group('main_attack')
  if group_status:  
    remove_from_group('main_attack')
  else:
    add_to_group('main_attack')
  var toggleable_gear_cell_maker = $makeGearUiCell
  if toggleable_gear_cell_maker != null:
    Comp.run_method(toggleable_gear_cell_maker, 'toggle', [not group_status])
  

func handle_left_clicked(event: InputEventMouse):
  get_viewport().set_input_as_handled()
  if Lib.is_dragging:
    return
  if not (event is InputEventMouseButton):
    return
  if event.pressed:
    return
  if event.button_index != MOUSE_BUTTON_LEFT:
    return
  if get_parent() != Lib.player_character:
    return
  #only when not dragging, as child of player character, and left button just released:
  toggle_equipped(Lib.player_character)












"

[node name="genericEnemy" type="CharacterBody2D"]
collision_layer = 2
motion_mode = 1
metadata/_edit_group_ = true
metadata/generation_bias = 1.0
metadata/faction_object = ["enemies"]

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
visible = false
shape = SubResource("RectangleShape2D_lhxg7")

[node name="healthStats" type="Node" parent="."]
script = SubResource("GDScript_ukxk7")

[node name="walkAbility" type="Node" parent="."]
script = SubResource("GDScript_a6mdq")

[node name="walkTowardTargetedObject" type="Node" parent="."]
script = SubResource("GDScript_mc3c8")

[node name="randomlyWalk" type="Node" parent="."]
script = SubResource("GDScript_r3k68")

[node name="targetNearestNonfaction" type="Area2D" parent="."]
collision_layer = 0
collision_mask = 2
script = SubResource("GDScript_lg7e8")

[node name="CollisionShape2D" type="CollisionShape2D" parent="targetNearestNonfaction"]
visible = false
shape = SubResource("RectangleShape2D_fsmxm")

[node name="setTargetPointToTargetObject" type="Node" parent="."]
script = SubResource("GDScript_p77ub")

[node name="shootConstantlyAtTargetObject" type="Node" parent="."]
script = SubResource("GDScript_gsacq")

[node name="makeBasicDamagePopups" type="Node2D" parent="."]
position = Vector2(0, -8)
script = SubResource("GDScript_67g1a")

[node name="dieOnZeroHp" parent="." instance=ExtResource("2_w4e45")]

[node name="dropLootOnDie" type="Node" parent="."]
script = SubResource("GDScript_m1ony")
bag_scene = ExtResource("3_ggkc0")
guaranteed_loot_scenes = [ExtResource("4_gw6bl")]

[node name="freeOnDie" type="Node" parent="."]
script = SubResource("GDScript_u32rb")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture_filter = 1
material = ExtResource("5_785rt")
texture = ExtResource("6_hlf5o")
region_rect = Rect2(0, 0, 10, 10)

[node name="produceShotAbility" type="Node" parent="." groups=["ability", "gear", "main_attack"]]
script = SubResource("GDScript_48n0u")
cast_speed = 80.0
max_attack_rate = 40
shot_resource = ExtResource("7_5qofr")
metadata/ui_cell_display = ExtResource("8_35tak")
metadata/ui_cell_left_click = "equip"

[connection signal="body_entered" from="targetNearestNonfaction" to="targetNearestNonfaction" method="_on_targetNearestNonfaction_body_entered"]
[connection signal="body_exited" from="targetNearestNonfaction" to="targetNearestNonfaction" method="_on_targetNearestNonfaction_body_exited"]
